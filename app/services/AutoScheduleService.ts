import { Job, WorkDay } from '../types/WorkTypes';
import { JobService } from './JobService';

export interface ScheduleConflict {
  date: string;
  conflicts: {
    job1: Job;
    job2: Job;
    overlap: {
      start: string;
      end: string;
    };
  }[];
}

export interface AutoScheduleResult {
  generatedDays: WorkDay[];
  conflicts: ScheduleConflict[];
  freeDays: WorkDay[];
}

export class AutoScheduleService {
  /**
   * Generate work days automatically for a job based on its schedule
   */
  static async generateWorkDays(
    job: Job, 
    startDate: Date, 
    endDate: Date
  ): Promise<AutoScheduleResult> {
    if (!job.schedule || !job.schedule.autoSchedule) {
      return { generatedDays: [], conflicts: [], freeDays: [] };
    }

    // Helper function to get work days from new weeklySchedule structure
    const getWorkDaysFromSchedule = (schedule: any): number[] => {
      if (schedule.weeklySchedule) {
        // New structure: get days that have schedules
        return Object.keys(schedule.weeklySchedule)
          .map(Number)
          .filter(day => schedule.weeklySchedule[day] !== null);
      } else if (schedule.workDays) {
        // Legacy structure: use workDays array
        return schedule.workDays;
      }
      return [];
    };

    const workDays = getWorkDaysFromSchedule(job.schedule);

    const generatedDays: WorkDay[] = [];
    const conflicts: ScheduleConflict[] = [];
    const freeDays: WorkDay[] = [];

    // Get existing work days to check for conflicts
    const existingWorkDays = await JobService.getWorkDays();
    
    const currentDate = new Date(startDate);
    
    while (currentDate <= endDate) {
      const dateString = this.formatDateString(currentDate);
      const dayOfWeek = currentDate.getDay();
      
      // Check if this day is a work day for this job
      if (workDays.includes(dayOfWeek)) {
        // Create work day(s) for this job
        const workDays = this.createWorkDaysForDate(job, dateString);
        
        // Check for conflicts with existing work days
        const dayConflicts = await this.checkScheduleConflicts(workDays, existingWorkDays);
        
        if (dayConflicts.length > 0) {
          conflicts.push({
            date: dateString,
            conflicts: dayConflicts
          });
        }
        
        generatedDays.push(...workDays);
      } else {
        // Check if this day has no work scheduled for any job
        const hasAnyWork = existingWorkDays.some(wd => 
          wd.date === dateString && wd.type === 'work'
        );
        
        if (!hasAnyWork) {
          // Create a free day
          const freeDay: WorkDay = {
            id: `free_${dateString}`,
            date: dateString,
            hours: 0,
            type: 'free',
            overtime: false,
            isAutoGenerated: true,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          };
          freeDays.push(freeDay);
        }
      }
      
      // Move to next day
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return { generatedDays, conflicts, freeDays };
  }

  /**
   * Create WorkDay objects for a specific date and job
   */
  private static createWorkDaysForDate(job: Job, dateString: string): WorkDay[] {
    const schedule = job.schedule!;
    const workDays: WorkDay[] = [];

    // Get day of week from date string
    const date = new Date(dateString);
    const dayOfWeek = date.getDay();

    // Get schedule for this specific day
    let daySchedule;
    if (schedule.weeklySchedule && schedule.weeklySchedule[dayOfWeek]) {
      daySchedule = schedule.weeklySchedule[dayOfWeek];
    } else {
      // Legacy fallback
      daySchedule = {
        startTime: schedule.startTime || '09:00',
        endTime: schedule.endTime || '17:00',
        hasSplitShift: schedule.hasSplitShift || false,
        secondStartTime: schedule.secondStartTime,
        secondEndTime: schedule.secondEndTime,
        breakTime: schedule.breakTime || 60,
      };
    }

    if (!daySchedule) {
      return workDays; // No schedule for this day
    }

    // Calculate hours based on schedule
    const mainHours = this.calculateHours(daySchedule.startTime, daySchedule.endTime);
    let totalHours = mainHours;

    // Main work period
    const mainWorkDay: WorkDay = {
      id: `${job.id}_${dateString}`,
      date: dateString,
      jobId: job.id,
      hours: mainHours,
      type: 'work',
      overtime: false,
      startTime: daySchedule.startTime,
      endTime: daySchedule.endTime,
      isAutoGenerated: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // If split shift, create second period
    if (daySchedule.hasSplitShift && daySchedule.secondStartTime && daySchedule.secondEndTime) {
      const secondHours = this.calculateHours(daySchedule.secondStartTime, daySchedule.secondEndTime);
      totalHours += secondHours;

      const secondWorkDay: WorkDay = {
        id: `${job.id}_${dateString}_2`,
        date: dateString,
        jobId: job.id,
        hours: secondHours,
        type: 'work',
        overtime: false,
        startTime: daySchedule.secondStartTime,
        endTime: daySchedule.secondEndTime,
        secondStartTime: daySchedule.secondStartTime,
        secondEndTime: daySchedule.secondEndTime,
        isAutoGenerated: true,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      workDays.push(secondWorkDay);
    }

    // Update main work day with total hours
    mainWorkDay.hours = totalHours;
    workDays.unshift(mainWorkDay); // Add main period first

    return workDays;
  }

  /**
   * Check for schedule conflicts between work days
   */
  private static async checkScheduleConflicts(
    newWorkDays: WorkDay[], 
    existingWorkDays: WorkDay[]
  ): Promise<any[]> {
    const conflicts: any[] = [];
    
    for (const newDay of newWorkDays) {
      if (!newDay.startTime || !newDay.endTime || !newDay.jobId) continue;
      
      const conflictingDays = existingWorkDays.filter(existing => 
        existing.date === newDay.date && 
        existing.jobId !== newDay.jobId &&
        existing.startTime && 
        existing.endTime &&
        this.hasTimeOverlap(
          newDay.startTime!, newDay.endTime!,
          existing.startTime, existing.endTime
        )
      );

      // Add conflicts to list (simplified for now)
      conflicts.push(...conflictingDays);
    }

    return conflicts;
  }

  /**
   * Generate schedule for a specific month
   */
  static async generateScheduleForMonth(job: Job, month: number, year?: number): Promise<AutoScheduleResult> {
    if (!job.schedule?.autoSchedule) {
      throw new Error('Auto schedule is not enabled for this job');
    }

    const currentYear = year || new Date().getFullYear();
    const startDate = new Date(currentYear, month, 1);
    const endDate = new Date(currentYear, month + 1, 0); // Last day of the month

    const result = await this.generateWorkDays(job, startDate, endDate);

    // Save generated work days
    for (const workDay of result.generatedDays) {
      const { id, createdAt, updatedAt, ...workDayData } = workDay;
      await JobService.addWorkDay(workDayData);
    }

    return result;
  }

  /**
   * Apply auto-generated schedule to calendar
   */
  static async applyAutoSchedule(job: Job): Promise<AutoScheduleResult> {
    if (!job.schedule?.autoSchedule) {
      throw new Error('Auto schedule is not enabled for this job');
    }

    // Generate for next 30 days (1 month)
    const startDate = new Date();
    const endDate = new Date();
    endDate.setDate(startDate.getDate() + 30);

    const result = await this.generateWorkDays(job, startDate, endDate);

    // Save generated work days
    for (const workDay of result.generatedDays) {
      const { id, createdAt, updatedAt, ...workDayData } = workDay;
      await JobService.addWorkDay(workDayData);
    }

    // Save free days
    for (const freeDay of result.freeDays) {
      const { id, createdAt, updatedAt, ...freeDayData } = freeDay;
      await JobService.addWorkDay(freeDayData);
    }

    return result;
  }

  /**
   * Clear auto-generated schedule for a job
   */
  static async clearAutoSchedule(jobId: string): Promise<void> {
    const workDays = await JobService.getWorkDays();
    
    // Debug: Log all work days to see what we have
    console.log('All work days:', workDays.map(wd => ({
      id: wd.id,
      type: wd.type,
      jobId: wd.jobId,
      isAutoGenerated: wd.isAutoGenerated,
      date: wd.date
    })));
    
    // Filter auto-generated days for this specific job AND auto-generated free days
    const autoGeneratedDays = workDays.filter(wd => 
      wd.isAutoGenerated && (
        // Work days for this specific job
        (wd.jobId === jobId) ||
        // Free days (they are auto-generated and have type 'free' with no jobId)
        (wd.type === 'free' && (wd.jobId === undefined || wd.jobId === null || wd.jobId === ''))
      )
    );
    
    console.log('Auto-generated days to delete:', autoGeneratedDays.length);
    console.log('Days to delete:', autoGeneratedDays.map(wd => ({
      id: wd.id,
      type: wd.type,
      jobId: wd.jobId,
      date: wd.date
    })));

    for (const workDay of autoGeneratedDays) {
      await JobService.deleteWorkDay(workDay.id);
    }
  }

  /**
   * Utility functions
   */
  private static formatDateString(date: Date): string {
    return date.toISOString().split('T')[0];
  }

  private static calculateHours(startTime: string, endTime: string): number {
    const [startHour, startMinute] = startTime.split(':').map(Number);
    const [endHour, endMinute] = endTime.split(':').map(Number);
    
    const startTotalMinutes = startHour * 60 + startMinute;
    const endTotalMinutes = endHour * 60 + endMinute;
    
    const diffMinutes = endTotalMinutes - startTotalMinutes;
    return Math.round((diffMinutes / 60) * 100) / 100; // Round to 2 decimals
  }

  private static hasTimeOverlap(
    start1: string, end1: string,
    start2: string, end2: string
  ): boolean {
    const [s1Hour, s1Min] = start1.split(':').map(Number);
    const [e1Hour, e1Min] = end1.split(':').map(Number);
    const [s2Hour, s2Min] = start2.split(':').map(Number);
    const [e2Hour, e2Min] = end2.split(':').map(Number);

    const start1Minutes = s1Hour * 60 + s1Min;
    const end1Minutes = e1Hour * 60 + e1Min;
    const start2Minutes = s2Hour * 60 + s2Min;
    const end2Minutes = e2Hour * 60 + e2Min;

    return !(end1Minutes <= start2Minutes || end2Minutes <= start1Minutes);
  }

  /**
   * Get schedule conflicts for a specific date range
   */
  static async getScheduleConflicts(startDate: Date, endDate: Date): Promise<ScheduleConflict[]> {
    const workDays = await JobService.getWorkDays();
    const jobs = await JobService.getJobs();
    const conflicts: ScheduleConflict[] = [];

    const currentDate = new Date(startDate);
    
    while (currentDate <= endDate) {
      const dateString = this.formatDateString(currentDate);
      const dayWorkDays = workDays.filter(wd => wd.date === dateString && wd.type === 'work');
      
      if (dayWorkDays.length > 1) {
        const dayConflicts: any[] = [];
        
        for (let i = 0; i < dayWorkDays.length; i++) {
          for (let j = i + 1; j < dayWorkDays.length; j++) {
            const wd1 = dayWorkDays[i];
            const wd2 = dayWorkDays[j];
            
            if (wd1.startTime && wd1.endTime && wd2.startTime && wd2.endTime) {
              if (this.hasTimeOverlap(wd1.startTime, wd1.endTime, wd2.startTime, wd2.endTime)) {
                const job1 = jobs.find(j => j.id === wd1.jobId);
                const job2 = jobs.find(j => j.id === wd2.jobId);
                
                if (job1 && job2) {
                  dayConflicts.push({
                    job1,
                    job2,
                    overlap: {
                      start: wd1.startTime > wd2.startTime ? wd1.startTime : wd2.startTime,
                      end: wd1.endTime < wd2.endTime ? wd1.endTime : wd2.endTime
                    }
                  });
                }
              }
            }
          }
        }
        
        if (dayConflicts.length > 0) {
          conflicts.push({
            date: dateString,
            conflicts: dayConflicts
          });
        }
      }
      
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return conflicts;
  }
}