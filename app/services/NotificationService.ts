import * as Notifications from 'expo-notifications';
import { Platform, AppState, Linking } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Configure notification behavior to show alerts even when app is in foreground
Notifications.setNotificationHandler({
  handleNotification: async (notification) => {
    console.log('üîî Notification handler called:', notification.request.identifier);
    console.log('   Content:', notification.request.content.title);
    console.log('   Type:', notification.request.content.data?.type);
    
    // For work reminders, check if it's actually time
    if (notification.request.content.data?.type === 'work_reminder') {
      console.log('‚è∞ Work reminder detected - checking timing...');
      
      const scheduledTime = notification.request.content.data?.timestamp;
      if (scheduledTime) {
        const scheduledDate = new Date(scheduledTime as string);
        const now = new Date();
        const timeDiff = Math.abs(scheduledDate.getTime() - now.getTime());
        
        console.log(`   Scheduled: ${scheduledDate.toLocaleString()}`);
        console.log(`   Now: ${now.toLocaleString()}`);  
        console.log(`   Difference: ${Math.round(timeDiff / 1000)} seconds`);
        
        // Show if within 30 seconds of scheduled time
        if (timeDiff <= 30000) {
          console.log('‚úÖ Showing work reminder - timing is correct');
          return {
            shouldShowAlert: true,
            shouldPlaySound: true,
            shouldSetBadge: false,
            priority: Notifications.AndroidNotificationPriority.HIGH,
          };
        } else {
          console.log('‚ùå NOT showing work reminder - timing is off');
          return {
            shouldShowAlert: false,
            shouldPlaySound: false,
            shouldSetBadge: false,
          };
        }
      }
      
      // Fallback - show if no timestamp data
      console.log('‚ö†Ô∏è No timestamp data, showing anyway');
      return {
        shouldShowAlert: true,
        shouldPlaySound: true,
        shouldSetBadge: false,
        priority: Notifications.AndroidNotificationPriority.HIGH,
      };
    }
    
    // For other notifications (test, auto-timer), show normally
    return {
      shouldShowAlert: true,
      shouldPlaySound: true,
      shouldSetBadge: false,
      priority: Notifications.AndroidNotificationPriority.HIGH,
    };
  },
});

export interface NotificationSettings {
  enabled: boolean;          // Notificaciones generales
  autoTimer: boolean;        // Notificaciones de auto-timer
  workReminders: boolean;    // Recordatorios de trabajo
  reminderMinutes: number;   // Minutos antes del horario de trabajo para recordatorio
}

export type NotificationType = 
  | 'timer_started'      // Timer iniciado autom√°ticamente
  | 'timer_stopped'      // Timer pausado autom√°ticamente
  | 'timer_will_start'   // Timer se iniciar√° en X minutos
  | 'timer_will_stop';   // Timer se pausar√° en X minutos

class NotificationService {
  private static instance: NotificationService;
  private hasPermissions = false;
  private pendingTimeouts = new Map<string, NodeJS.Timeout>();
  private pendingWorkReminders = new Map<string, { reminderDate: Date; jobName: string; startTime: string; minutesBefore: number }>();
  private settings: NotificationSettings = {
    enabled: true,
    autoTimer: true,
    workReminders: true,
    reminderMinutes: 15,
  };

  private constructor() {
    this.initializeService();
    this.setupAppStateListener();
  }

  static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }

  /**
   * Initialize the notification service
   */
  private async initializeService(): Promise<void> {
    try {
      console.log('üîß Initializing NotificationService...');
      
      // Load saved settings
      await this.loadSettings();
      
      const success = await this.requestPermissions();
      console.log('üîß Initialization complete. Success:', success);
    } catch (error) {
      console.error('Error initializing notification service:', error);
    }
  }

  /**
   * Setup AppState listener to handle background notifications
   */
  private setupAppStateListener(): void {
    AppState.addEventListener('change', (nextAppState) => {
      console.log('üì± AppState changed to:', nextAppState);
      
      if (nextAppState === 'background' || nextAppState === 'inactive') {
        console.log('üì≤ App going to background - scheduling pending work reminders');
        this.schedulePendingWorkReminders();
      }
    });
  }

  /**
   * Schedule all pending work reminders when app goes to background
   */
  private async schedulePendingWorkReminders(): Promise<void> {
    if (this.pendingWorkReminders.size === 0) {
      console.log('üì≠ No pending work reminders to schedule');
      return;
    }

    console.log(`üì¨ Scheduling ${this.pendingWorkReminders.size} pending work reminders`);
    
    for (const [identifier, reminder] of this.pendingWorkReminders.entries()) {
      try {
        await this.scheduleWorkReminderInternal(
          reminder.reminderDate,
          reminder.jobName,
          reminder.startTime,
          reminder.minutesBefore,
          identifier
        );
      } catch (error) {
        console.error(`‚ùå Error scheduling pending reminder ${identifier}:`, error);
      }
    }
    
    // Clear pending reminders after scheduling
    this.pendingWorkReminders.clear();
    console.log('‚úÖ All pending work reminders scheduled and cleared');
  }

  /**
   * Request notification permissions
   */
  async requestPermissions(): Promise<boolean> {
    try {
      console.log('üîê Requesting notification permissions...');
      
      if (Platform.OS === 'ios') {
        const { status: existingStatus } = await Notifications.getPermissionsAsync();
        console.log('üîç Existing permission status:', existingStatus);
        
        let finalStatus = existingStatus;

        if (existingStatus !== 'granted') {
          console.log('üì± Requesting permissions...');
          const { status } = await Notifications.requestPermissionsAsync({
            ios: {
              allowAlert: true,
              allowBadge: true,
              allowSound: true,
              allowDisplayInCarPlay: false,
              allowCriticalAlerts: false,
              provideAppNotificationSettings: false,
              allowProvisional: false,
            },
          });
          finalStatus = status;
          console.log('üì± Permission request result:', finalStatus);
        }

        this.hasPermissions = finalStatus === 'granted';
        
        if (!this.hasPermissions) {
          console.warn('‚ùå Notification permissions not granted. Status:', finalStatus);
          console.warn('üì± Go to Settings > Notifications > YourApp to enable notifications');
          return false;
        }
      } else {
        // Android permissions are handled automatically by expo-notifications
        this.hasPermissions = true;
      }

      console.log('‚úÖ Notification permissions granted');
      return true;
    } catch (error) {
      console.error('Error requesting notification permissions:', error);
      this.hasPermissions = false;
      return false;
    }
  }

  /**
   * Check if notifications are available and enabled
   */
  canSendNotifications(): boolean {
    return this.hasPermissions && this.settings.enabled;
  }

  /**
   * Get current notification permission status
   */
  async getPermissionStatus(): Promise<'granted' | 'denied' | 'undetermined'> {
    try {
      const { status } = await Notifications.getPermissionsAsync();
      return status;
    } catch (error) {
      console.error('Error getting permission status:', error);
      return 'undetermined';
    }
  }

  /**
   * Open system settings for notifications
   */
  async openNotificationSettings(): Promise<void> {
    try {
      if (Platform.OS === 'ios') {
        await Linking.openURL('app-settings:');
      } else {
        await Linking.openSettings();
      }
    } catch (error) {
      console.error('Error opening notification settings:', error);
    }
  }

  /**
   * Send a local notification
   */
  async sendNotification(
    type: NotificationType,
    jobName: string,
    extraData?: { minutes?: number }
  ): Promise<void> {
    try {
      console.log('üöÄ sendNotification called with:', { type, jobName, extraData });
      console.log('üîç hasPermissions:', this.hasPermissions);
      console.log('üîç settings:', this.settings);
      console.log('üîç canSendNotifications():', this.canSendNotifications());
      
      if (!this.canSendNotifications()) {
        console.log('üìµ Notifications disabled or no permissions');
        console.log('üìµ hasPermissions:', this.hasPermissions);
        console.log('üìµ settings.enabled:', this.settings.enabled);
        return;
      }

      // Check if auto-timer notifications are enabled
      if (type.startsWith('timer_') && !this.settings.autoTimer) {
        console.log('üìµ Auto-timer notifications disabled');
        return;
      }

      const { title, body } = this.getNotificationContent(type, jobName, extraData);
      const identifier = `${type}_${Date.now()}`;

      await Notifications.scheduleNotificationAsync({
        identifier,
        content: {
          title,
          body,
          sound: true,
          priority: Notifications.AndroidNotificationPriority.HIGH,
          data: {
            type,
            jobName,
            timestamp: new Date().toISOString(),
          },
        },
        trigger: null, // Send immediately
      });

      console.log(`üì± Notification sent: ${title} - ${body}`);
    } catch (error) {
      console.error('Error sending notification:', error);
    }
  }

  /**
   * Get notification content based on type
   */
  private getNotificationContent(
    type: NotificationType,
    jobName: string,
    extraData?: { minutes?: number }
  ): { title: string; body: string } {
    const minutes = extraData?.minutes || 2;

    switch (type) {
      case 'timer_started':
        return {
          title: '‚è∞ Timer Iniciado',
          body: `Timer autom√°tico iniciado para "${jobName}"`,
        };

      case 'timer_stopped':
        return {
          title: '‚èπÔ∏è Timer Pausado',
          body: `Timer autom√°tico pausado para "${jobName}"`,
        };

      case 'timer_will_start':
        return {
          title: 'üöÄ Timer se Iniciar√°',
          body: `Timer se iniciar√° en ${minutes} minutos para "${jobName}"`,
        };

      case 'timer_will_stop':
        return {
          title: '‚è∏Ô∏è Timer se Pausar√°',
          body: `Timer se pausar√° en ${minutes} minutos para "${jobName}"`,
        };

      default:
        return {
          title: 'üì± Notificaci√≥n',
          body: `Evento para "${jobName}"`,
        };
    }
  }

  /**
   * Load settings from AsyncStorage
   */
  private async loadSettings(): Promise<void> {
    try {
      const settingsJson = await AsyncStorage.getItem('notification_settings');
      if (settingsJson) {
        this.settings = { ...this.settings, ...JSON.parse(settingsJson) };
        console.log('üì± Loaded notification settings:', this.settings);
      } else {
        // Save default settings
        await AsyncStorage.setItem('notification_settings', JSON.stringify(this.settings));
        console.log('üì± Saved default notification settings');
      }
    } catch (error) {
      console.error('Error loading notification settings:', error);
    }
  }

  /**
   * Update notification settings
   */
  async updateSettings(newSettings: Partial<NotificationSettings>): Promise<void> {
    this.settings = { ...this.settings, ...newSettings };
    
    // Save settings to AsyncStorage for background access
    try {
      await AsyncStorage.setItem('notification_settings', JSON.stringify(this.settings));
    } catch (error) {
      console.error('Error saving notification settings:', error);
    }
    
    console.log('üì± Notification settings updated:', this.settings);
  }

  /**
   * Get current settings
   */
  getSettings(): NotificationSettings {
    return { ...this.settings };
  }

  /**
   * Cancel all pending notifications
   */
  async cancelAllNotifications(): Promise<void> {
    try {
      await Notifications.cancelAllScheduledNotificationsAsync();
      console.log('üóëÔ∏è All notifications cancelled');
    } catch (error) {
      console.error('Error cancelling notifications:', error);
    }
  }

  /**
   * Cancel notifications by type
   */
  async cancelNotificationsByType(type: NotificationType): Promise<void> {
    try {
      const scheduledNotifications = await Notifications.getAllScheduledNotificationsAsync();
      const notificationsToCancel = scheduledNotifications.filter(
        notification => notification.content.data?.type === type
      );

      for (const notification of notificationsToCancel) {
        await Notifications.cancelScheduledNotificationAsync(notification.identifier);
      }

      console.log(`üóëÔ∏è Cancelled ${notificationsToCancel.length} notifications of type: ${type}`);
    } catch (error) {
      console.error('Error cancelling notifications by type:', error);
    }
  }

  /**
   * Test notification (for debugging)
   */
  async sendTestNotification(): Promise<void> {
    console.log('üß™ sendTestNotification called');
    try {
      const identifier = `test_${Date.now()}`;
      
      await Notifications.scheduleNotificationAsync({
        identifier,
        content: {
          title: 'üß™ Test Notification',
          body: 'If you see this, notifications are working correctly',
          sound: true,
          priority: Notifications.AndroidNotificationPriority.HIGH,
        },
        trigger: null, // Send immediately
      });
      
      console.log('‚úÖ Test notification sent');
      
      // Also try to present it manually for foreground
      await Notifications.presentNotificationAsync({
        title: 'üß™ Foreground Test',
        body: 'This should show as alert in foreground',
        sound: true,
        priority: Notifications.AndroidNotificationPriority.HIGH,
      });
      
    } catch (error) {
      console.error('‚ùå Error in sendTestNotification:', error);
    }
  }

  /**
   * Schedule test notification with delay (for testing with app closed)
   */
  async scheduleDelayedTestNotification(delaySeconds: number = 20): Promise<void> {
    console.log(`‚è∞ Scheduling delayed test notification in ${delaySeconds} seconds`);
    try {
      const identifier = `delayed_test_${Date.now()}`;
      const scheduledTime = new Date(Date.now() + delaySeconds * 1000);
      
      console.log(`üìÖ Current time: ${new Date().toLocaleTimeString()}`);
      console.log(`üìÖ Will trigger at: ${scheduledTime.toLocaleTimeString()}`);
      
      await Notifications.scheduleNotificationAsync({
        identifier,
        content: {
          title: 'üß™ Background Test',
          body: `This notification was scheduled ${delaySeconds} seconds ago. If you see this, background notifications work!`,
          sound: true,
          priority: Notifications.AndroidNotificationPriority.HIGH,
        },
        trigger: {
          type: 'timeInterval',
          seconds: delaySeconds,
        } as any,
      });
      
      console.log(`‚úÖ Delayed test notification scheduled successfully`);
    } catch (error) {
      console.error('‚ùå Error scheduling delayed test notification:', error);
    }
  }

  /**
   * Schedule work reminder notification (public method)
   */
  async scheduleWorkReminder(
    reminderDate: Date,
    jobName: string,
    startTime: string,
    minutesBefore: number
  ): Promise<void> {
    console.log('üîî scheduleWorkReminder called with:');
    console.log('   reminderDate:', reminderDate.toLocaleString());
    console.log('   jobName:', jobName);
    console.log('   startTime:', startTime);
    console.log('   minutesBefore:', minutesBefore);

    if (!this.hasPermissions || !this.settings.workReminders) {
      console.log('‚ùå Cannot schedule: no permissions or setting disabled');
      return;
    }

    const identifier = `work_reminder_${jobName}_${reminderDate.getTime()}`;
    
    // Always schedule immediately - no need to wait for background
    console.log('üì≤ Scheduling work reminder immediately');
    await this.scheduleWorkReminderInternal(reminderDate, jobName, startTime, minutesBefore, identifier);
  }

  /**
   * Internal method to actually schedule the work reminder notification
   */
  private async scheduleWorkReminderInternal(
    reminderDate: Date,
    jobName: string,
    startTime: string,
    minutesBefore: number,
    identifier: string
  ): Promise<void> {
    try {
      let title = '‚è∞ Recordatorio de Trabajo';
      let body = '';
      
      if (minutesBefore === 0) {
        body = `Es hora de empezar a trabajar en ${jobName} (${startTime})`;
      } else if (minutesBefore === 1) {
        body = `En 1 minuto empieza tu turno en ${jobName} (${startTime})`;
      } else if (minutesBefore < 60) {
        body = `En ${minutesBefore} minutos empieza tu turno en ${jobName} (${startTime})`;
      } else {
        const hours = Math.floor(minutesBefore / 60);
        const mins = minutesBefore % 60;
        const timeText = mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        body = `En ${timeText} empieza tu turno en ${jobName} (${startTime})`;
      }

      console.log('üìù Scheduling notification:');
      console.log('   title:', title);
      console.log('   body:', body);
      console.log('   identifier:', identifier);
      console.log('   scheduled for:', reminderDate.toLocaleString());

      const now = new Date();
      const timeUntilTrigger = reminderDate.getTime() - now.getTime();

      console.log(`‚è±Ô∏è Time until trigger: ${timeUntilTrigger}ms (${Math.round(timeUntilTrigger/1000)}s)`);
      
      if (timeUntilTrigger <= 0) {
        console.log('‚è≠Ô∏è SKIPPING: Notification time has already passed');
        return;
      }
      
      const notificationRequest = await Notifications.scheduleNotificationAsync({
        identifier,
        content: {
          title,
          body,
          sound: true,
          priority: Notifications.AndroidNotificationPriority.HIGH,
          data: {
            type: 'work_reminder',
            jobName,
            startTime,
            minutesBefore,
            timestamp: reminderDate.toISOString(),
          },
        },
        trigger: {
          type: 'date',
          date: reminderDate,
        } as any,
      });

      console.log(`‚úÖ Work reminder scheduled successfully!`);
      console.log(`   Notification ID: ${notificationRequest}`);
      console.log(`   For: ${reminderDate.toLocaleString()}`);
      
      // Verify the notification was scheduled
      const scheduledNotifications = await Notifications.getAllScheduledNotificationsAsync();
      const ourNotification = scheduledNotifications.find(n => n.identifier === identifier);
      if (ourNotification) {
        console.log(`üìã Verified: Notification found in scheduled list`);
        console.log(`   Trigger: ${ourNotification.trigger ? 'Date-based' : 'Immediate'}`);
      } else {
        console.log(`‚ùå ERROR: Notification not found in scheduled list!`);
      }
      
    } catch (error) {
      console.error('‚ùå Error scheduling work reminder:', error);
    }
  }

  /**
   * Cancel all work reminder notifications
   */
  async cancelWorkReminders(): Promise<void> {
    try {
      // Cancel scheduled notifications
      const scheduledNotifications = await Notifications.getAllScheduledNotificationsAsync();
      const workReminderIds = scheduledNotifications
        .filter(notification => 
          notification.identifier.startsWith('work_reminder_') ||
          notification.content.data?.type === 'work_reminder'
        )
        .map(notification => notification.identifier);

      if (workReminderIds.length > 0) {
        for (const id of workReminderIds) {
          await Notifications.cancelScheduledNotificationAsync(id);
        }
        console.log(`üóëÔ∏è Cancelled ${workReminderIds.length} scheduled work reminder notifications`);
      }

      // Cancel pending timeouts
      let timeoutCount = 0;
      for (const [identifier, timeoutId] of this.pendingTimeouts.entries()) {
        if (identifier.startsWith('work_reminder_')) {
          clearTimeout(timeoutId);
          this.pendingTimeouts.delete(identifier);
          timeoutCount++;
        }
      }
      
      if (timeoutCount > 0) {
        console.log(`üóëÔ∏è Cancelled ${timeoutCount} pending timeout work reminders`);
      }

      // Clear pending work reminders
      const pendingCount = this.pendingWorkReminders.size;
      this.pendingWorkReminders.clear();
      
      if (pendingCount > 0) {
        console.log(`üóëÔ∏è Cleared ${pendingCount} pending work reminders`);
      }
      
    } catch (error) {
      console.error('Error cancelling work reminders:', error);
    }
  }

}

export default NotificationService;